// Code generated by "enumer -type=dimensionOrder -trimprefix=dimensionOrder -text -transform=kebab -output enums_dimensionorder.go"; DO NOT EDIT.

//
package imagine

import (
	"fmt"
)

const _dimensionOrderName = "rowcolumn"

var _dimensionOrderIndex = [...]uint8{0, 3, 9}

func (i dimensionOrder) String() string {
	if i < 0 || i >= dimensionOrder(len(_dimensionOrderIndex)-1) {
		return fmt.Sprintf("dimensionOrder(%d)", i)
	}
	return _dimensionOrderName[_dimensionOrderIndex[i]:_dimensionOrderIndex[i+1]]
}

var _dimensionOrderValues = []dimensionOrder{0, 1}

var _dimensionOrderNameToValueMap = map[string]dimensionOrder{
	_dimensionOrderName[0:3]: 0,
	_dimensionOrderName[3:9]: 1,
}

// dimensionOrderString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func dimensionOrderString(s string) (dimensionOrder, error) {
	if val, ok := _dimensionOrderNameToValueMap[s]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to dimensionOrder values", s)
}

// dimensionOrderValues returns all values of the enum
func dimensionOrderValues() []dimensionOrder {
	return _dimensionOrderValues
}

// IsAdimensionOrder returns "true" if the value is listed in the enum definition. "false" otherwise
func (i dimensionOrder) IsAdimensionOrder() bool {
	for _, v := range _dimensionOrderValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalText implements the encoding.TextMarshaler interface for dimensionOrder
func (i dimensionOrder) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for dimensionOrder
func (i *dimensionOrder) UnmarshalText(text []byte) error {
	var err error
	*i, err = dimensionOrderString(string(text))
	return err
}
