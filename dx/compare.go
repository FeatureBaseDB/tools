package dx

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
	"reflect"
	"text/tabwriter"
	"time"

	"github.com/pkg/errors"
	"github.com/spf13/cobra"
)

// NewCompareCommand initializes a new compare command for dx.
func NewCompareCommand() *cobra.Command {
	compareCmd := &cobra.Command{
		Use:   "compare",
		Short: "compare two dx solo results",
		Long:  `Compare two result files generated by dx solo command.`,
		Args: func(cmd *cobra.Command, args []string) error {
			return validateComparisonArgs(args)
		},
		Run: func(cmd *cobra.Command, args []string) {
			if err := ExecuteComparison(args[0], args[1]); err != nil {
				fmt.Printf("%+v", err)
				os.Exit(1)
			}
		},
	}

	return compareCmd
}

// validateCompareArgs validates that the args passed to compare command has length exactly 2
// and are valid filenames.
func validateComparisonArgs(args []string) error {
	if len(args) != 2 {
		return errors.New("need exactly two files to compare")
	}
	fileExists, err := checkFileExists(args[0])
	if err != nil {
		return errors.Wrapf(err, "error verifying file %s exists", args[0])
	}
	if !fileExists {
		return errors.Errorf("%s does not exist", args[0])
	}
	fileExists, err = checkFileExists(args[1])
	if err != nil {
		return errors.Wrapf(err, "error verifying file %s exists", args[1])
	}
	if !fileExists {
		return errors.Errorf("%s does not exist", args[1])
	}
	return nil
}

// Comparison struct contains the information of a comparison. RunTime is the total time it took for the run to complete.
// The TotalTime is the total of all the individual times of each operation, which may have been running in separate goroutines.
type Comparison struct {
	Type           string
	RunTime1       time.Duration
	RunTime2       time.Duration
	RunTimeDelta   float64
	TotalTime1     time.Duration
	TotalTime2     time.Duration
	TotalTimeDelta float64
	ThreadCount1   int
	ThreadCount2   int
	Accuracy       float64
	Size           int64
}

// ExecuteComparison executes a comparison on the two files.
func ExecuteComparison(file1, file2 string) error {
	benchChan1 := make(chan *Benchmark)
	benchChan2 := make(chan *Benchmark)
	cmdTypeChan1 := make(chan string)
	cmdTypeChan2 := make(chan string)

	go readResults(file1, benchChan1, cmdTypeChan1)
	go readResults(file2, benchChan2, cmdTypeChan2)

	cmdType1 := <-cmdTypeChan1
	cmdType2 := <-cmdTypeChan2

	if cmdType1 != cmdType2 {
		return errors.Errorf("results files types don't match: %v and %v", cmdType1, cmdType2)
	}

	switch cmdType1 {
	case cmdIngest:

		b1 := <-benchChan1
		b2 := <-benchChan2

		// compare ingest
		comparison, err := compareIngest(b1, b2)
		if err != nil {
			return errors.Wrap(err, "error comparing ingest")
		}
		// print results
		if err := printIngestResults(comparison); err != nil {
			return errors.Wrap(err, "error printing ingest results")
		}
		return nil
	case cmdQuery:
		// consolidate benches
		benches1 := make([]*Benchmark, 0)
		benches2 := make([]*Benchmark, 0)
		for b := range benchChan1 {
			benches1 = append(benches1, b)
		}
		for b := range benchChan2 {
			benches2 = append(benches2, b)
		}

		// compare queries
		comparison, err := compareQueries(benches1, benches2)
		if err != nil {
			return errors.Wrap(err, "error comparing queries")
		}

		// print results
		if err := printQueryResults(comparison); err != nil {
			return errors.Wrap(err, "error printing query results")
		}
		return nil
	// even though there is cmdTotal, it must never be at the start of a file, so that is an error.
	default:
		return errors.Errorf("invalid command type: %v", cmdType1)
	}
}

// compareQueries returns the total time of all the individual queries, as well as the total time of the run and additional analysis.
func compareQueries(benches1, benches2 []*Benchmark) (*Comparison, error) {
	var runTime1, runTime2 time.Duration

	// queryMap only contains valid queries from benches1
	queryMap := make(map[int64]*Query)
	for _, b1 := range benches1 {
		if b1.Type == cmdTotal {
			runTime1 = b1.Time.Duration
			continue
		}
		if isValidQuery(b1.Query) {
			queryMap[b1.Query.ID] = b1.Query
		}
	}

	// validQueries is the number of queries that successfully ran on both clusters.
	// This is not equivalent to the number of queries with correct results.
	var validQueries int64
	var numCorrect int64
	var totalTime1, totalTime2 time.Duration

	for _, b2 := range benches2 {
		if b2.Type == cmdTotal {
			runTime2 = b2.Time.Duration
			continue
		}

		query2 := b2.Query
		// if query1 is found, it must already be a valid query
		if query1, found := queryMap[query2.ID]; found {
			if isValidQuery(query2) && queryResultsEqual(query1, query2) {
				numCorrect++
			}
			totalTime1 += query1.Time.Duration
			totalTime2 += query2.Time.Duration
			validQueries++
		}
	}

	totalTimeDelta, err := compareTime(totalTime1, totalTime2)
	if err != nil {
		return nil, errors.Wrap(err, "error comparing time")
	}
	runTimeDelta, err := compareTime(runTime1, runTime2)
	if err != nil {
		return nil, errors.Wrap(err, "error comparing time")
	}
	accuracy := float64(numCorrect) / float64(validQueries)

	threadCount1 := benches1[0].ThreadCount
	threadCount2 := benches2[0].ThreadCount

	return &Comparison{
		Type:           cmdQuery,
		RunTime1:       runTime1,
		RunTime2:       runTime2,
		RunTimeDelta:   runTimeDelta,
		TotalTime1:     totalTime1,
		TotalTime2:     totalTime2,
		TotalTimeDelta: totalTimeDelta,
		ThreadCount1:   threadCount1,
		ThreadCount2:   threadCount2,
		Accuracy:       accuracy,
		Size:           validQueries,
	}, nil
}

func compareIngest(b1, b2 *Benchmark) (*Comparison, error) {
	// analyze time
	timeDelta, err := compareTime(b1.Time.Duration, b2.Time.Duration)
	if err != nil {
		return nil, errors.Wrap(err, "error comparing time")
	}

	return &Comparison{
		Type:         cmdIngest,
		RunTime1:     b1.Time.Duration,
		RunTime2:     b2.Time.Duration,
		RunTimeDelta: timeDelta,
		ThreadCount1: b1.ThreadCount,
		ThreadCount2: b2.ThreadCount,
	}, nil
}

// compareTime takes two durations and returns the delta.
func compareTime(time1, time2 time.Duration) (float64, error) {
	if time1 == 0 {
		return 0, errors.New("time1 is zero")
	}
	if time2 == 0 {
		return 0, errors.New("time2 is zero")
	}
	timeDelta := float64(time2-time1) / float64(time1)
	return timeDelta, nil
}

// queryResultsEqual compares the results of two valid queries. If both queries have
// different result types (i.e. result and resultCount), we count the number of results
// and compare the two counts. Results are prioritized over resultCounts.
func queryResultsEqual(query1, query2 *Query) bool {
	// one of query1.Result and query1.ResultCount is not nil
	if query1.Result == nil {
		if query2.Result == nil {
			return *query1.ResultCount == *query2.ResultCount
		}
		return *query1.ResultCount == int64(len(query2.Result.Columns))
	}
	// else, query1.Result is not nil
	if query2.Result == nil {
		return int64(len(query1.Result.Columns)) == *query2.ResultCount
	}
	return reflect.DeepEqual(query1.Result, query2.Result)
}

// isValidQuery checks if a query is valid. A valid query has at least one of
// result or resultCount as a non-nil value.
func isValidQuery(query *Query) bool {
	if query == nil {
		return false
	}
	if query.Result == nil && query.ResultCount == nil {
		return false
	}
	return true
}

// readResults streams the decoded benchmarks from file into benchChan. This also checks
// the bench type of the first decoded benchmark and sends this to the cmdTypeChan. The function
// closes both channels if no errors are returned.
func readResults(file string, benchChan chan *Benchmark, cmdTypeChan chan string) {
	fileReader, err := os.Open(file)
	if err != nil {
		log.Fatalf("error opening file %v: %v", file, err)
	}

	decoder := json.NewDecoder(fileReader)

	// check first benchmark for its type
	bench := NewBenchmark()
	if err := decoder.Decode(&bench); err == io.EOF {
		log.Fatalf("empty file %v: %v", file, err)
	} else if err != nil {
		log.Fatalf("error decoding json from %v: %v", file, err)
	}

	cmdTypeChan <- bench.Type
	close(cmdTypeChan)
	benchChan <- bench

	// keep reading until EOF or error
	for {
		bench := NewBenchmark()
		if err := decoder.Decode(&bench); err == io.EOF {
			break
		} else if err != nil {
			log.Fatalf("error decoding json from %v: %v", file, err)
		}
		benchChan <- bench
	}
	close(benchChan)
}

// printIngestResults prints the results of dx query.
func printIngestResults(c *Comparison) error {
	w := new(tabwriter.Writer)
	w.Init(os.Stdout, 10, 5, 5, ' ', tabwriter.AlignRight)

	// print in percentage
	delta := c.RunTimeDelta * 100

	fmt.Fprintf(w, "ingest\t\tfirst-threads%v\tsecond-threads%v\tdelta\t\n", c.ThreadCount1, c.ThreadCount2)
	fmt.Fprintf(w, "\t\t%v\t%v\t%.1f%%\t\n", c.RunTime1, c.RunTime2, delta)
	fmt.Fprintln(w)
	if err := w.Flush(); err != nil {
		return errors.Wrap(err, "could not flush writer")
	}
	return nil
}

// printQueryResults prints the results of dx query.
func printQueryResults(c *Comparison) error {
	w := new(tabwriter.Writer)
	w.Init(os.Stdout, 10, 5, 5, ' ', tabwriter.AlignRight)
	fmt.Fprintf(w, "queries\taccuracy\tfirst-threads%v\tsecond-threads%v\tdelta\t\n", c.ThreadCount1, c.ThreadCount2)

	// print in percentages
	accuracy := c.Accuracy * 100
	runTimeDelta := c.RunTimeDelta * 100
	totalTimeDelta := c.TotalTimeDelta * 100

	// average ms/op
	ave1 := (float64(c.TotalTime1) / float64(c.Size)) / float64(1000000)
	ave2 := (float64(c.TotalTime2) / float64(c.Size)) / float64(1000000)
	fmt.Fprintf(w, "%v\t%.1f%%\t%.3f ms/op\t%.3f ms/op\t%.1f%%\t\n", c.Size, accuracy, ave1, ave2, totalTimeDelta)
	fmt.Fprintf(w, "%v\t%v\t%v\t%v\t%.1f%%\t\n", "TOTAL", "", c.RunTime1, c.RunTime2, runTimeDelta)
	fmt.Fprintln(w)
	if err := w.Flush(); err != nil {
		return errors.Wrap(err, "could not flush writer")
	}
	return nil
}

// checkFileExists checks whether a file exists at path.
func checkFileExists(path string) (bool, error) {
	fileInfo, err := os.Stat(path)
	if os.IsNotExist(err) {
		return false, nil
	} else if err != nil {
		return false, errors.Wrap(err, "error statting path")
	}
	fileMode := fileInfo.Mode()
	return fileMode.IsRegular(), nil
}
