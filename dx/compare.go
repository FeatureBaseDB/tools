package dx

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
	"reflect"
	"sync"
	"text/tabwriter"
	"time"

	"github.com/pkg/errors"
	"github.com/spf13/cobra"
)

// NewCompareCommand initializes a new compare command for dx.
func NewCompareCommand() *cobra.Command {
	compareCmd := &cobra.Command{
		Use:   "compare",
		Short: "compare two dx solo results",
		Long:  `Compare two result files generated by dx solo command.`,
		Args: func(cmd *cobra.Command, args []string) error {
			return validateComparisonArgs(args)
		},
		Run: func(cmd *cobra.Command, args []string) {

			if err := ExecuteComparison(args[0], args[1]); err != nil {
				fmt.Printf("%+v", err)
				os.Exit(1)
			}

		},
	}

	return compareCmd
}

// validateCompareArgs validates that the args passed to compare command has length exactly 2
// and are valid filenames.
func validateComparisonArgs(args []string) error {
	if len(args) != 2 {
		return errors.New("need exactly two files to compare")
	}
	fileExists, err := checkFileExists(args[0])
	if err != nil {
		return errors.Wrapf(err, "error verifying file %s exists", args[0])
	}
	if !fileExists {
		return errors.Errorf("%s does not exist", args[0])
	}
	fileExists, err = checkFileExists(args[1])
	if err != nil {
		return errors.Wrapf(err, "error verifying file %s exists", args[1])
	}
	if !fileExists {
		return errors.Errorf("%s does not exist", args[1])
	}
	return nil
}

// ExecuteComparison executes a comparison on the two files.
func ExecuteComparison(file1, file2 string) error {
	benchChan1 := make(chan *Benchmark)
	benchChan2 := make(chan *Benchmark)
	cmdTypeChan1 := make(chan string)
	cmdTypeChan2 := make(chan string)

	go readResults(file1, benchChan1, cmdTypeChan1)
	go readResults(file2, benchChan2, cmdTypeChan2)

	cmdType1 := <-cmdTypeChan1
	cmdType2 := <-cmdTypeChan2

	if cmdType1 != cmdType2 {
		return errors.Errorf("results files types don't match: %v and %v", cmdType1, cmdType2)
	}

	switch cmdType1 {
	case cmdIngest:

		b1 := <-benchChan1
		b2 := <-benchChan2

		// analyze time
		timeDelta, err := compareTime(b1.Time.Duration, b2.Time.Duration)
		if err != nil {
			return errors.Wrap(err, "error comparing time")
		}
		// print results
		if err := printIngestResults(b1.Time.Duration, b2.Time.Duration, timeDelta); err != nil {
			return errors.Wrap(err, "error printing ingest results")
		}
		return nil
	case cmdQuery:

		// consolidate benches
		benches1 := make([]*Benchmark, 0)
		benches2 := make([]*Benchmark, 0)
		var wg sync.WaitGroup
		wg.Add(1)
		go func() {
			defer wg.Done()
			for b := range benchChan1 {
				benches1 = append(benches1, b)
			}
		}()
		wg.Add(1)
		go func() {
			defer wg.Done()
			for b := range benchChan2 {
				benches2 = append(benches2, b)
			}
		}()

		wg.Wait()
		
		// analyze benchmarks
		time1, time2, validQueries, timeDelta, accuracy, err := compareQueries(benches1, benches2)
		if err != nil {
			return errors.Wrap(err, "error comparing queries")
		}

		// print results
		if err := printQueryResults(time1, time2, validQueries, timeDelta, accuracy); err != nil {
			return errors.Wrap(err, "error printing query results")
		}
		return nil
	default:
		return errors.Errorf("invalid command type: %v", cmdType1)
	}
}

func compareQueries(benches1, benches2 []*Benchmark) (time.Duration, time.Duration, int64, float64, float64, error) {
	// queryMap only contains valid queries from benches1
	queryMap := make(map[int64]*Query)
	for _, b1 := range benches1 {
		if isValidQuery(b1.Query) {
			queryMap[b1.Query.ID] = b1.Query
		}
	}

	// validQueries is the number of queries that successfully ran on both clusters.
	// This is not equivalent to the number of queries with correct results.
	var validQueries int64
	var numCorrect int64
	var time1, time2 time.Duration

	for _, b2 := range benches2 {
		query2 := b2.Query

		// if query1 is found, it must already be a valid query
		if query1, found := queryMap[query2.ID]; found {

			if isValidQuery(query2) && queryResultsEqual(query1, query2) {
				numCorrect++
			}
			time1 += query1.Time.Duration
			time2 += query2.Time.Duration
			validQueries++
		}
	}

	timeDelta, err := compareTime(time1, time2)
	if err != nil {
		return 0, 0, 0, 0, 0, errors.Wrap(err, "error comparing time")
	}
	accuracy := float64(numCorrect) / float64(validQueries)

	return time1, time2, validQueries, timeDelta, accuracy, nil
}

// compareTime takes two durations and returns the delta.
func compareTime(time1, time2 time.Duration) (float64, error) {
	if time1 == 0 {
		return 0, errors.New("time1 is zero")
	}
	if time2 == 0 {
		return 0, errors.New("time2 is zero")
	}
	timeDelta := float64(time2-time1) / float64(time1)
	return timeDelta, nil
}

// queryResultsEqual compares the results of two valid queries. If both queries have
// different result types (i.e. result and resultCount), we count the number of results
// and compare the two counts. Results are prioritized over resultCounts.
func queryResultsEqual(query1, query2 *Query) bool {
	// one of query1.Result and query1.ResultCount is not nil
	if query1.Result == nil {
		if query2.Result == nil {
			return *query1.ResultCount == *query2.ResultCount
		}
		return *query1.ResultCount == int64(len(query2.Result.Columns))
	}
	// else, query1.Result is not nil
	if query2.Result == nil {
		return int64(len(query1.Result.Columns)) == *query2.ResultCount
	}
	return reflect.DeepEqual(query1.Result, query2.Result)
}

// isValidQuery checks if a query is valid. A valid query has at least one of
// result or resultCount as a non-nil value.
func isValidQuery(query *Query) bool {
	if query.Result == nil && query.ResultCount == nil {
		return false
	}
	return true
}

// readResults streams the decoded benchmarks from file into benchChan. This also checks
// the bench type of the first decoded benchmark and sends this to the cmdTypeChan. The function
// closes both channels if no errors are returned.
func readResults(file string, benchChan chan *Benchmark, cmdTypeChan chan string) {
	fileReader, err := os.Open(file)
	if err != nil {
		log.Fatalf("error opening file %v: %v", file, err)
	}

	decoder := json.NewDecoder(fileReader)

	// check first benchmark for its type
	bench := NewBenchmark()
	if err := decoder.Decode(&bench); err == io.EOF {
		log.Fatalf("empty file %v: %v", file, err)
	} else if err != nil {
		log.Fatalf("error decoding json from %v: %v", file, err)
	}

	cmdTypeChan <- bench.Type
	close(cmdTypeChan)
	benchChan <- bench

	// keep reading until EOF or error
	for {
		bench := NewBenchmark()
		if err := decoder.Decode(&bench); err == io.EOF {
			break
		} else if err != nil {
			log.Fatalf("error decoding json from %v: %v", file, err)
		}
		benchChan <- bench
	}
	close(benchChan)
}

// printIngestResults prints the results of dx query.
func printIngestResults(time1, time2 time.Duration, delta float64) error {
	w := new(tabwriter.Writer)
	w.Init(os.Stdout, 10, 5, 5, ' ', tabwriter.AlignRight)
	fmt.Fprintf(w, "ingest\t\tfirst\tsecond\tdelta\t\n")
	fmt.Fprintf(w, "\t\t%v\t%v\t%.1f%%\t\n", time1, time2, delta)
	fmt.Fprintln(w)
	if err := w.Flush(); err != nil {
		return errors.Wrap(err, "could not flush writer")
	}
	return nil
}

// printQueryResults prints the results of dx query.
func printQueryResults(time1, time2 time.Duration, numQueries int64, delta, accuracy float64) error {
	w := new(tabwriter.Writer)
	w.Init(os.Stdout, 10, 5, 5, ' ', tabwriter.AlignRight)
	fmt.Fprintf(w, "queries\taccuracy\tfirst\tsecond\tdelta\t\n")

	// print in percentages
	accuracy = accuracy * 100
	delta = delta * 100

	// average ms/op
	ave1 := (float64(time1) / float64(numQueries)) / float64(1000000)
	ave2 := (float64(time2) / float64(numQueries)) / float64(1000000)
	fmt.Fprintf(w, "%v\t%.1f%%\t%.3f ms/op\t%.3f ms/op\t%.1f%%\t", numQueries, accuracy, ave1, ave2, delta)
	fmt.Fprintln(w)
	if err := w.Flush(); err != nil {
		return errors.Wrap(err, "could not flush writer")
	}
	return nil
}

// checkFileExists checks whether a file exists at path.
func checkFileExists(path string) (bool, error) {
	fileInfo, err := os.Stat(path)
	if os.IsNotExist(err) {
		return false, nil
	} else if err != nil {
		return false, errors.Wrap(err, "error statting path")
	}
	fileMode := fileInfo.Mode()
	return fileMode.IsRegular(), nil
}
